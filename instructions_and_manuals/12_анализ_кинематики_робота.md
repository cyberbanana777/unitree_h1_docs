# Ограничения по  значениям принимаемых углов для каждого суства

**Эти ограничения указаны в [оффициальной документации от Unitree](https://support.unitree.com/home/en/developer).**

# Определение направления осей
Когда все шарниры находятся в нулевом положении, система координат выглядит так, как показано на следующем рисунке. Красная ось обозначает ось X, зелёная — ось Y, а синяя — ось Z.

![Оси кооррдинат, когда шарниры находятся в нулевом положении](photo_for_instructions/robot_analysis/the_hinges_are_in_the_zero_position.png)


*Рисунок 1 - Оси кооррдинат, когда шарниры находятся в нулевом положении*

## Опционально:

Вы также можете посмотреть эту визуализацию вживую и поэкспериментировать с моделью робота в Rviz. Для этого необходимо:

1.  **Установите Rviz** (обычно входит в состав ROS2).
2.  **Установите и соберите необходимые репозитории:**
    *   [`unitree_h1_visualization_ws`](https://github.com/cyberbanana777/unitree_h1_visualization_ws) — следуя приложенной инструкции.
    *   [`unitree_h1_control_ws`](https://github.com/cyberbanana777/unitree_h1_control_ws) — если он ещё не установлен.

При установке зависимотей скриптом (3 шаг в `unitree_h1_visualization_ws`) смотрите на вывод скрипта в терминале, иногда нужно запустить его из-под sudo.
Это значит написать перед текстом команды sudo и запустить, а потом ввести пароль.

3.  **Запустите систему.**

Сначала запустите launch-файл для визуализации модели робота:
```bash
ros2 launch completed_scripts_visualization show.launch.py mode:=without_hands launch_rviz:=True robot:=simulation
```

![Робот в rviz](photo_for_instructions/robot_analysis/robot_in_rviz.png)

*Рисунок 2 - Робот в rviz*

- Красная ось обозначает ось X, зелёная — ось Y, а синяя — ось Z.
- Show Axes - покажет оси.
- Frames - можно включить или выключить отображение определенных осей.

Затем, в отдельном терминале, запустите ноду для отправки управляющих сигналов, чтобы задавать движение модели:
```bash
ros2 run low_level_control low_level_control_without_hands_node
```

### Дополнительная возможность: Графический интерфейс

Для упрощённого задания углов суставов вы можете дополнительно запустить [графический интерфейс](https://github.com/cyberbanana777/unitree_h1_control_ws?tab=readme-ov-file#gui_control) `gui_control_node`.

```bash
ros2 run gui_control gui_control_node
```

> **Примечание:** Если репозиторий `unitree_h1_control_ws` уже установлен, для запуска графического интерфейса больше ничего не требуется.

![Робот в rviz](photo_for_instructions/robot_analysis/gui_control.png)

*Рисунок 3 - Графический интерфейс для управления роботом*

> Можно вводть координаты в поле с клавиатуры или изменять кнопками "+" и "-".

# Определение направления вращения для каждого звена в зависимости от поданного на мотор значения (угла)

Если выполнить инструкцию из опционального раздела предыдущего пункта, вы сможете управлять роботом через графический интерфейс в rviz и наблюдать, в какую сторону будет вращаться каждое звено.

В общем случае, можно реализовать то же самое в MuJoCo. Для этого:

1. **Установите MuJoCo** по инструкции `5_Как_установить_Mujoco_вместе_с_моделями_Unitree.md`
2. **Запустите симуляцию** - в правой части окна визуализатора вы найдете раскрывающееся поле **Control**
3. **Экспериментируйте** - через этот интерфейс можно независимо управлять каждым мотором и визуально определять положительное/отрицательное направление вращения.

![Управление моторами в mujoco](photo_for_instructions/robot_analysis/control_joints_in_mujoco.png)

*Рисунок 4 - Управление моторами в mujoco*

# Анализ URDF: расположения и наклоны link относительно друг друга

![Суставы Unitre H1](photo_for_instructions/robot_analysis/joints_h1.png)

*Рисунок 5 - Суставы Unitre H1*

## Общая структура описания звена и его

### 1. Звено (Link `<link>`)
**Тег `<link> `описывает жесткий сегмент робота, его физические и визуальные свойства. У каждого звена должно быть уникальное имя (name).**

Компоненты внутри `<link>`:
`<inertial>` (Инерционные параметры): Определяет массу и момент инерции звена. Критически важно для точного физического моделирования в симуляторах (например, Gazebo).

`<origin>`: Задает смещение и поворот центра инерции (Center of Mass) относительно геометрического центра звена.

`<mass>`: Масса звена в килограммах.

`<inertia>`: Тензор инерции, представляющий собой симметричную матрицу 3x3. Он описывает, как масса распределена вокруг осей координат. Параметры ixx, iyy, izz — это моменты инерции, а ixy, ixz, iyz — произведения инерции.

`<visual>` (Визуальное представление): Описывает, как звено выглядит в инструментах визуализации (таких как RVIZ2).

`<origin>`: Смещение и поворот визуальной геометрии относительно центра звена.

`<geometry>`: Определяет форму. Это может быть `<box>`, `<cylinder>`, `<sphere>`, или сложная <mesh> (обычно файл в формате .dae или .stl).

`<material>`: Определяет цвет (`<color>`) или текстуру звена.

`<collision>` (Коллизионная геометрия): Описывает форму, используемую движком физики для расчета столкновений. Эта геометрия часто бывает более простой, чем визуальная, для повышения производительности.

`<origin>`: Смещение и поворот коллизионной геометрии.

`<geometry>`: Форма для столкновений (аналогично визуальной).

Важно: Визуальная и коллизионная геометрии не обязаны совпадать. Упрощение коллизионной модели — стандартная практика.

### 2. Соединение (Joint `<joint>`)
**Тег `<joint>` описывает, как два звена связаны друг с другом, и определяет тип их относительного движения.**

Атрибуты и компоненты внутри `<joint>`:

- `name`: Уникальное имя соединения.

- `type`: Тип соединения, определяющий степени свободы:

  - `revolute` - вращательное соединение (с ограниченным углом).

  - `continuous` - вращательное соединение (без ограничений, как колесо).

  - `prismatic` - линейное (поступательное) соединение.

  - `fixed` - жесткое соединение (без движения).

  - `floating` - соединение с полной свободой движения.

  - `planar` - движение в плоскости.

**`<origin>`: Задает смещение и поворот от системы координат родительского звена к системе координат дочернего звена. Это преобразование, которое помещает дочернее звено в пространстве относительно родителя.**

#### Атрибут `xyz` - перемещение (translation)
- **Формат:** `"x y z"` в метрах
- **Значения:** `"0 0 0"`
- **Расшифровка:**
  - `x=0` - смещения по оси X (вперед/назад)
  - `y=0` - смещения по оси Y (влево/вправо) 
  - `z=0` - смещение по оси Z (вверх/вниз)

#### Атрибут `rpy` - поворот (rotation)
- **Формат:** `"roll pitch yaw"` в радианах
- **Значения:** `"0 0 0"`
- **Расшифровка:**
  - `roll=0` - крен (вращение вокруг оси X)
  - `pitch=0` - тангаж (вращение вокруг оси Y)
  - `yaw=0` - рысканье (вращение вокруг оси Z)

`<parent>`: Ссылка на родительское звено (link) в иерархии робота.

`<child>`: Ссылка на дочернее звено, которое присоединяется к родительскому.

`<axis>`: Определяет ось, вокруг которой (или вдоль которой) происходит движение. Задается единичным вектором в локальных координатах соединения. Например, xyz="1 0 0" означает ось X.

`<limit>`: Обязателен для соединений типа revolute и prismatic. Определяет рабочий диапазон соединения.

- `lower` - нижний предел (в радианах или метрах).

- `upper` - верхний предел.

- `effort` - максимальное усилие (крутящий момент для revolute или сила для prismatic), которое может приложить привод.

- `velocity` - максимальная скорость движения.

## Разбор примера левого голеностопного сустава

Нужно описание лажит по этому относительному адресу:

`unitree_h1_visualization_ws/src/h1_description/urdf/h1.urdf`

или по [этой ссылке](https://github.com/cyberbanana777/unitree_h1_visualization_ws/blob/main/h1_description/urdf/h1.urdf) в репоизитории `unitree_h1_visualization_ws`.

Рассмотрим левого голеностопного сустава, описанное в URDF,:

```bash
    <link
    name="left_ankle_link">
    <inertial>
        <origin
        xyz="0.042575 -0.000001 -0.044672"
        rpy="0 0 0" />
        <mass
        value="0.474" />
        <inertia
        ixx="0.000159668"
        ixy="-0.000000005"
        ixz="0.000141063"
        iyy="0.002900286"
        iyz="0.000000014"
        izz="0.002805438" />
    </inertial>
    <visual>
        <origin
        xyz="0 0 0"
        rpy="0 0 0" />
        <geometry>
        <mesh
            filename="package://h1_description/meshes/left_ankle_link.dae" />
        </geometry>
        <material
        name="">
        <color
            rgba="0.1 0.1 0.1 1" />
        </material>
    </visual>
    <collision>
        <origin xyz="0.05 0.0 -0.05" rpy="0 0 0" />
        <geometry>
        <box size="0.28 0.03 0.024"/>
        </geometry>
    </collision>
    </link>
    <joint
    name="left_ankle_joint"
    type="revolute">
    <origin
        xyz="0 0 -0.4"
        rpy="0 0 0" />
    <parent
        link="left_knee_link" />
    <child
        link="left_ankle_link" />
    <axis
        xyz="0 1 0" />
    <limit
        lower="-0.87"
        upper="0.52"
        effort="40"
        velocity="9" />
    </joint>

```

## Общая структура иерархии
Робот в URDF представляется в виде дерева звеньев, соединенных суставами. Начинается дерево с "корневого" звена (base link), которое не имеет родителя. Каждое последующее звено присоединяется к уже существующему в дереве с помощью сустава.

В вашем примере:

`left_knee_link` является родителем.

`left_ankle_link` является ребенком.

`left_ankle_joint` определяет, как именно ребенок соединен с родителем (включая смещение, ориентацию и ось вращения).


## Блок Соединения (Joint) - `left_ankle_joint`

Для определения нужных нам параматров достаточно расмотреть блок `<joint>`.

### Основные параметры соединения
```xml
<joint name="left_ankle_joint" type="revolute">
```

**Что это значит:**
- `name="left_ankle_joint"` - уникальное имя соединения
- `type="revolute"` - вращательный тип соединения (как шарнир)

### Геометрия соединения
```xml
<origin xyz="0 0 -0.4" rpy="0 0 0" />
```

**Что это значит:**
- Соединение расположено со смещением **-0.4 м (40 см)** по оси Z относительно родительского звена
- Это означает, что голеностоп находится на 40 см ниже коленного сустава
- И голеностоп не повернут ни по какой оси относительно коленного сустава

### Иерархия соединений
```xml
<parent link="left_knee_link" />
<child link="left_ankle_link" />
```

**Что это значит:**
- Родительское звено: `left_knee_link` (звено колена)
- Дочернее звено: `left_ankle_link` (текущее звено лодыжки)

### Ось вращения и ограничения
```xml
<axis xyz="0 1 0" />
<limit lower="-0.87" upper="0.52" effort="40" velocity="9" />
```

**Что это значит:**
- `<axis xyz="0 1 0">` - ось вращения направлена по оси Y
- `<limit>`:
  - `lower="-0.87"` - минимальный угол = **-0.87 радиан** (≈ -50°)
  - `upper="0.52"` - максимальный угол = **0.52 радиан** (≈ +30°)
  - `effort="40"` - максимальный крутящий момент = **40 Н·м**
  - `velocity="9"` - максимальная скорость = **9 рад/с** (≈ 515°/с)

## Физический смысл всей конструкции

Это описание **голеностопного сустава** робота:
- Звено представляет собой часть ноги в области лодыжки
- Соединение позволяет совершать движения типа "сгибание-разгибание" стопы
- Ограничения угла позволяют двигаться от подъема стопы (50°) до опускания (30°)

# Анализ URDF: длины звеньев

Проанализируем `right_hip_pitch_joint` из `urdf`:

```bash

<!-- right_hip_roll → right_hip_pitch -->
  <joint
    name="right_hip_pitch_joint"
    type="revolute">
    <origin
      xyz="0 -0.11536 0"
      rpy="0 0 0" />
    <parent
      link="right_hip_roll_link" />
    <child
      link="right_hip_pitch_link" />
    <axis
      xyz="0 1 0" />
    <limit
      lower="-3.14"
      upper="2.53"
      effort="200"
      velocity="23" />
  </joint>

```

![Суставы Unitre H1](photo_for_instructions/robot_analysis/left_pitch_roll_axes.png)

*Рисунок 6 - Система координат right_hip_roll_link (справа) и right_hip_pitch_link (слева)*

**Расчёт длины звена**

В данном случае длина звена равна расстоянию между центрами систем координат `right_hip_roll_link` и `right_hip_pitch_link`.

Смещение между ними задано вектором `xyz="0 -0.11536 0"`. Поскольку смещение присутствует только по оси Y, длина звена рассчитывается просто как модуль этого значения:

Длина = | -0.11536 | = 0.11536 метра.

**В общем случае, если бы смещение было по нескольким осям, длина находилась бы по формуле √(x² + y² + z²).**


Конечно! Вот отредактированный текст. Он стал более структурированным, понятным и приятным для чтения.

---

### Как преобразовать координаты между системами отсчёта робота

Для работы с преобразованиями координат в ROS 2 используется утилита `tf2_echo`. Она подписывается на систему трансформаций (TF) и выводит в консоль преобразование между двумя указанными системами отсчёта (фреймами).

**Важное условие:** Для работы утилиты робот должен публиковать описания своих фреймов и преобразований между ними в соответствующих топиках.

### 1. Запуск системы преобразований

В репозитории [unitree_h1_visualization_ws](https://github.com/cyberbanana777/unitree_h1_visualization_ws) при запуске show.launch.py, релализован зпуск преобразований для робота Unitree H1. Вы можете установить репозиторий по инструкции по ссылке выше.

Вы можете запустить публикацию преобразований с помощью репозитрия `unitree_h1_visualization_ws` в нескольких вариациях, подробнее [тут](https://github.com/cyberbanana777/unitree_h1_visualization_ws/tree/main?tab=readme-ov-file#-использование):

*   **Полный запуск с визуализацией в Rviz:** Используется для отладки и визуального контроля.

```bash
ros2 launch h1_description description.launch.py mode:=without_hands launch_rviz:=True
```

*   **Запуск без визуализации:** 

```bash
ros2 launch h1_description description.launch.py mode:=without_hands
```
Эта команда покажет все существующие аргументы для launch файла и их значения, что позволит запустить его для любой ситации - на рельном роботе или нет и тд.

```bash
ros2 launch completed_scripts_visualization show.launch.py -s
```

**Проверить что преобразования работают можно, запустив команду:** 

```bash
ros2 node list
```
В списке нод должна быть нода под названием `/robot_state_publisher`

### 2. Использование утилиты `tf2_echo`

**Формат команды:**
```bash
ros2 run tf2_ros tf2_echo <исходный_фрейм> <целевой_фрейм>
```

**Пример:**
Чтобы получить преобразование из таза (`pelvis`) в звено правого плеча (`right_shoulder_pitch_link`), выполните:

```bash
ros2 run tf2_ros tf2_echo pelvis right_shoulder_pitch_link
```

**Где найти названия фреймов?**
*   В окне визуализации Rviz (в разделе TF).
*   В URDF-описании модели робота.

#### 3. Как интерпретировать результат

После запуска команды в консоль начнёт выводиться информация примерно следующего вида:

```bash
At time 1761151063.357288585
- Translation: [0.005, -0.155, 0.430]
- Rotation: in Quaternion [-0.216, 0.000, 0.000, 0.976]
```

**Расшифровка данных:**

*   **Translation `[x, y, z]`** — это вектор перемещения (в метрах) от исходного фрейма к целевому.
    *   **X = 0.005 м**: Правое плечо находится почти прямо по оси X от таза (слегка впереди).
    *   **Y = -0.155 м**: Отрицательное значение по оси Y означает, что плечо смещено влево от таза (в стандартной системе координат робота ось Y обычно направлена влево).
    *   **Z = 0.430 м**: Положительное значение указывает, что плечо находится значительно выше таза.

*   **Rotation `[x, y, z, w]`** — это ориентация, представленная в виде кватерниона.
    *   В данном примере ненулевые компоненты `x` и `w` указывают на поворот в основном вокруг оси X.

#### Важное замечание

Преобразования между фреймами публикуются постоянно и меняются в реальном времени по мере движения звеньев робота.

**Для получения статичных и корректных данных:** Установите робота (или его симуляционную модель) в нужное положение, дождитесь прекращения движений, и только затем снимите показания с помощью `tf2_echo`.

## Преобразование точки из одной системы координат в другую, матричный метод

Общая формула преобразования точки из системы A в систему B:

**P₂ = R × P₁ + t**

где:
- **P₁** = [x₁, y₁, z₁] - точка в исходной системе координат
- **P₂** = [x₂, y₂, z₂] - точка в целевой системе координат  
- **R** - матрица поворота 3×3
- **t** = [tₓ, tᵧ, t₂] - вектор

## 2. Данные

```
Translation: t = [0.005, -0.155, 0.430]
Rotation: q = [-0.216, 0.000, 0.000, 0.976]  # [x, y, z, w]
Point: P₁ = [0.1, 0.2, 0.3]
```

## 3. Преобразование кватерниона в матрицу поворота

### Формула кватерниона:
q = [x, y, z, w] = [qₓ, qᵧ, q₂, q_w]

### Матрица поворота из кватерниона:

```
    [1-2(qᵧ²+q₂²)   2(qₓqᵧ-q_wq₂)   2(qₓq₂+q_wqᵧ) ]
R = [2(qₓqᵧ+q_wq₂)   1-2(qₓ²+q₂²)   2(qᵧq₂-q_wqₓ) ]
    [2(qₓq₂-q_wqᵧ)   2(qᵧq₂+q_wqₓ)   1-2(qₓ²+qᵧ²) ]
```

### Для примера кватерниона q = [-0.216, 0.000, 0.000, 0.976]:

```
qₓ = -0.216, qᵧ = 0.000, q₂ = 0.000, q_w = 0.976

R = [1-2(0+0)       2(0-0)          2(0+0)        ]
    [2(0+0)         1-2(0.0467+0)   2(0-(-0.211)) ]
    [2(0-0)         2(0+(-0.211))   1-2(0.0467+0) ]

R = [1.000  0.000  0.000]
    [0.000  0.907  0.422]
    [0.000 -0.422  0.907]
```

## 4. Применение поворота

**P_rotated = R × P₁**

```
[1.000  0.000  0.000]   [0.1]   [0.1]
[0.000  0.907  0.422] × [0.2] = [0.907×0.2 + 0.422×0.3] = [0.1814 + 0.1266] = [0.308]
[0.000 -0.422  0.907]   [0.3]   [-0.422×0.2 + 0.907×0.3] = [-0.0844 + 0.2721] = [0.188]
```

**P_rotated = [0.1, 0.308, 0.188]**

## 5. Применение вектора перемещения

**P₂ = P_rotated + t**

```
P₂ = [0.1, 0.308, 0.188] + [0.005, -0.155, 0.430]
P₂ = [0.105, 0.153, 0.618]
```

## Преобразование точки из одной системы координат в другую с помщью ROS2 ноды

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PointStamped
from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener
from tf2_geometry_msgs import do_transform_point

class BasicTFTransformer(Node):
    def __init__(self):
        # 1. Инициализируем ноду с именем 'basic_tf_transformer'
        super().__init__('basic_tf_transformer')
        
        # 2. Создаем буфер для хранения трансформаций
        self.tf_buffer = Buffer()
        
        # 3. Создаем "слушателя" трансформаций
        self.tf_listener = TransformListener(self.tf_buffer, self)
        
        self.get_logger().info("Базовая TF нода инициализирована")

    def transform_point(self, point_xyz, from_frame, to_frame):
        """
        Преобразует точку из одной системы координат в другую
        
        Args:
            point_xyz: список [x, y, z] - координаты точки в исходной системе
            from_frame: строка - имя исходной системы координат
            to_frame: строка - имя целевой системы координат
        
        Returns:
            список [x, y, z] - координаты точки в целевой системе
        """
        try:
            # 4. Получаем трансформацию между системами координат
            transform = self.tf_buffer.lookup_transform(
                to_frame,           # целевая система
                from_frame,         # исходная система  
                rclpy.time.Time()   # время (0 - последняя доступная трансформация)
            )
            
            self.get_logger().info(f"Найдена трансформация: {from_frame} -> {to_frame}")
            
            # 5. Создаем сообщение PointStamped для исходной точки
            point_stamped = PointStamped()
            point_stamped.header.frame_id = from_frame  # указываем систему координат точки
            point_stamped.header.stamp = self.get_clock().now().to_msg()  # текущее время
            point_stamped.point.x = point_xyz[0]
            point_stamped.point.y = point_xyz[1] 
            point_stamped.point.z = point_xyz[2]
            
            # 6. Применяем трансформацию к точке
            transformed_point = do_transform_point(point_stamped, transform)
            
            # 7. Возвращаем результат
            return [
                transformed_point.point.x,
                transformed_point.point.y,
                transformed_point.point.z
            ]
            
        except TransformException as e:
            self.get_logger().error(f"Ошибка преобразования: {e}")
            return None

def main():
    # 8. Инициализируем ROS2
    rclpy.init()
    
    # 9. Создаем экземпляр ноды
    transformer = BasicTFTransformer()
    
    try:
        # 10. Определяем точку для преобразования
        point_in_pelvis = [0.1, 0.2, 0.3]  # x, y, z в метрах
        
        # 11. Преобразуем точку
        point_in_shoulder = transformer.transform_point(
            point_in_pelvis,
            'pelvis',                   # исходная система
            'right_shoulder_pitch_link' # целевая система
        )
        
        # 12. Выводим результат
        if point_in_shoulder:
            transformer.get_logger().info("Преобразование успешно!")
            transformer.get_logger().info(f"Точка в 'pelvis': {point_in_pelvis}")
            transformer.get_logger().info(f"Точка в 'right_shoulder_pitch_link': {point_in_shoulder}")
        else:
            transformer.get_logger().error("Преобразование не удалось")
            
    except KeyboardInterrupt:
        pass
    finally:
        # 13. Корректно завершаем работу
        transformer.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Пошаговое объяснение работы ноды:

### **1. Инициализация ноды**
```python
super().__init__('basic_tf_transformer')
```
- Создается ROS2 нода с именем `basic_tf_transformer`
- Это имя будет видно в `ros2 node list`

### **2. Создание буфера трансформаций**
```python
self.tf_buffer = Buffer()
```
- `Buffer` хранит историю трансформаций между разными системами координат
- Автоматически обновляется при поступлении новых трансформаций

### **3. Создание слушателя**
```python
self.tf_listener = TransformListener(self.tf_buffer, self)
```
- `TransformListener` подписывается на топик `/tf` и автоматически заполняет буфер
- Работает в фоновом режиме

### **4. Получение трансформации**
```python
transform = self.tf_buffer.lookup_transform(
    to_frame,           # куда преобразуем
    from_frame,         # откуда преобразуем  
    rclpy.time.Time()   # время трансформации
)
```
- `lookup_transform` ищет преобразование между двумя системами координат
- `rclpy.time.Time()` означает "последняя доступная трансформация"

### **5. Создание PointStamped**
```python
point_stamped = PointStamped()
point_stamped.header.frame_id = from_frame
point_stamped.point.x = point_xyz[0]
# ...
```
- `PointStamped` - это сообщение, которое содержит:
  - `header.frame_id` - система координат точки
  - `point.x, y, z` - координаты точки

### **6. Применение трансформации**
```python
transformed_point = do_transform_point(point_stamped, transform)
```
- `do_transform_point` применяет математическое преобразование к точке
- Внутри происходит: **P₂ = R × P₁ + t** (поворот + смещение)

## 🚀 Как запустить:

**Терминал 1:** Запускаем публикацию трансформаций
```bash
ros2 run robot_state_publisher robot_state_publisher /home/user/unitree_h1_visualization_ws/src/h1_description/urdf/h1.urdf
```

**Терминал 2:** Запускаем нашу ноду
```bash
chmod +x basic_tf_transformer.py
python3 basic_tf_transformer.py
```

## 📊 Ожидаемый вывод:
```
[INFO] [basic_tf_transformer]: Базовая TF нода инициализирована
[INFO] [basic_tf_transformer]: Найдена трансформация: pelvis -> right_shoulder_pitch_link
[INFO] [basic_tf_transformer]: Преобразование успешно!
[INFO] [basic_tf_transformer]: Точка в 'pelvis': [0.1, 0.2, 0.3]
[INFO] [basic_tf_transformer]: Точка в 'right_shoulder_pitch_link': [0.105, 0.153, 0.618]
```
